// Code generated by protoc-gen-go. DO NOT EDIT.
// source: actionplugin.proto

package actionplugin

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ActionPluginManifest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Author               string   `protobuf:"bytes,4,opt,name=author,proto3" json:"author,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActionPluginManifest) Reset()         { *m = ActionPluginManifest{} }
func (m *ActionPluginManifest) String() string { return proto.CompactTextString(m) }
func (*ActionPluginManifest) ProtoMessage()    {}
func (*ActionPluginManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8761e3c72e0ffc53, []int{0}
}

func (m *ActionPluginManifest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ActionPluginManifest.Unmarshal(m, b)
}
func (m *ActionPluginManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ActionPluginManifest.Marshal(b, m, deterministic)
}
func (m *ActionPluginManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionPluginManifest.Merge(m, src)
}
func (m *ActionPluginManifest) XXX_Size() int {
	return xxx_messageInfo_ActionPluginManifest.Size(m)
}
func (m *ActionPluginManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionPluginManifest.DiscardUnknown(m)
}

var xxx_messageInfo_ActionPluginManifest proto.InternalMessageInfo

func (m *ActionPluginManifest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActionPluginManifest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ActionPluginManifest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ActionPluginManifest) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

type ActionQuery struct {
	Options              map[string]string `protobuf:"bytes,1,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	JobID                int64             `protobuf:"varint,2,opt,name=jobID,proto3" json:"jobID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ActionQuery) Reset()         { *m = ActionQuery{} }
func (m *ActionQuery) String() string { return proto.CompactTextString(m) }
func (*ActionQuery) ProtoMessage()    {}
func (*ActionQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_8761e3c72e0ffc53, []int{1}
}

func (m *ActionQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ActionQuery.Unmarshal(m, b)
}
func (m *ActionQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ActionQuery.Marshal(b, m, deterministic)
}
func (m *ActionQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionQuery.Merge(m, src)
}
func (m *ActionQuery) XXX_Size() int {
	return xxx_messageInfo_ActionQuery.Size(m)
}
func (m *ActionQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ActionQuery proto.InternalMessageInfo

func (m *ActionQuery) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ActionQuery) GetJobID() int64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

type ActionResult struct {
	Status               string   `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Details              string   `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActionResult) Reset()         { *m = ActionResult{} }
func (m *ActionResult) String() string { return proto.CompactTextString(m) }
func (*ActionResult) ProtoMessage()    {}
func (*ActionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_8761e3c72e0ffc53, []int{2}
}

func (m *ActionResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ActionResult.Unmarshal(m, b)
}
func (m *ActionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ActionResult.Marshal(b, m, deterministic)
}
func (m *ActionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionResult.Merge(m, src)
}
func (m *ActionResult) XXX_Size() int {
	return xxx_messageInfo_ActionResult.Size(m)
}
func (m *ActionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ActionResult proto.InternalMessageInfo

func (m *ActionResult) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ActionResult) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

type StreamResult struct {
	Status               string   `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Details              string   `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	Logs                 string   `protobuf:"bytes,3,opt,name=logs,proto3" json:"logs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamResult) Reset()         { *m = StreamResult{} }
func (m *StreamResult) String() string { return proto.CompactTextString(m) }
func (*StreamResult) ProtoMessage()    {}
func (*StreamResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_8761e3c72e0ffc53, []int{3}
}

func (m *StreamResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamResult.Unmarshal(m, b)
}
func (m *StreamResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamResult.Marshal(b, m, deterministic)
}
func (m *StreamResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamResult.Merge(m, src)
}
func (m *StreamResult) XXX_Size() int {
	return xxx_messageInfo_StreamResult.Size(m)
}
func (m *StreamResult) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamResult.DiscardUnknown(m)
}

var xxx_messageInfo_StreamResult proto.InternalMessageInfo

func (m *StreamResult) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *StreamResult) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func (m *StreamResult) GetLogs() string {
	if m != nil {
		return m.Logs
	}
	return ""
}

type WorkerHTTPPortQuery struct {
	Port                 int32    `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkerHTTPPortQuery) Reset()         { *m = WorkerHTTPPortQuery{} }
func (m *WorkerHTTPPortQuery) String() string { return proto.CompactTextString(m) }
func (*WorkerHTTPPortQuery) ProtoMessage()    {}
func (*WorkerHTTPPortQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_8761e3c72e0ffc53, []int{4}
}

func (m *WorkerHTTPPortQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkerHTTPPortQuery.Unmarshal(m, b)
}
func (m *WorkerHTTPPortQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkerHTTPPortQuery.Marshal(b, m, deterministic)
}
func (m *WorkerHTTPPortQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerHTTPPortQuery.Merge(m, src)
}
func (m *WorkerHTTPPortQuery) XXX_Size() int {
	return xxx_messageInfo_WorkerHTTPPortQuery.Size(m)
}
func (m *WorkerHTTPPortQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerHTTPPortQuery.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerHTTPPortQuery proto.InternalMessageInfo

func (m *WorkerHTTPPortQuery) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func init() {
	proto.RegisterType((*ActionPluginManifest)(nil), "actionplugin.ActionPluginManifest")
	proto.RegisterType((*ActionQuery)(nil), "actionplugin.ActionQuery")
	proto.RegisterMapType((map[string]string)(nil), "actionplugin.ActionQuery.OptionsEntry")
	proto.RegisterType((*ActionResult)(nil), "actionplugin.ActionResult")
	proto.RegisterType((*StreamResult)(nil), "actionplugin.StreamResult")
	proto.RegisterType((*WorkerHTTPPortQuery)(nil), "actionplugin.WorkerHTTPPortQuery")
}

func init() {
	proto.RegisterFile("actionplugin.proto", fileDescriptor_8761e3c72e0ffc53)
}

var fileDescriptor_8761e3c72e0ffc53 = []byte{
	// 462 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc7, 0xe3, 0x38, 0x4d, 0x61, 0x12, 0x21, 0x18, 0xaa, 0xca, 0x98, 0x4b, 0xd8, 0x03, 0x94,
	0xcb, 0x16, 0x95, 0x4b, 0xd5, 0x03, 0x2a, 0x85, 0x4a, 0x45, 0xa2, 0xc2, 0xb8, 0x91, 0x90, 0xb8,
	0x39, 0xce, 0xd6, 0x31, 0x71, 0x3c, 0xd6, 0xee, 0x3a, 0x52, 0x2e, 0xbc, 0x0b, 0x2f, 0xc7, 0x73,
	0x20, 0xef, 0xda, 0xc8, 0x96, 0xe2, 0x03, 0xdc, 0x66, 0x76, 0x3e, 0x3c, 0xff, 0xdf, 0x8c, 0x01,
	0xa3, 0x58, 0xa7, 0x94, 0x17, 0x59, 0x99, 0xa4, 0x39, 0x2f, 0x24, 0x69, 0xc2, 0x69, 0xfb, 0xcd,
	0x7f, 0x9e, 0x10, 0x25, 0x99, 0x38, 0x35, 0xb1, 0x45, 0x79, 0x7f, 0x2a, 0x36, 0x85, 0xde, 0xd9,
	0x54, 0xf6, 0x13, 0x8e, 0xde, 0x9b, 0xe4, 0xc0, 0x24, 0xdf, 0x46, 0x79, 0x7a, 0x2f, 0x94, 0x46,
	0x84, 0x51, 0x1e, 0x6d, 0x84, 0xe7, 0xcc, 0x9c, 0x93, 0x87, 0xa1, 0xb1, 0xd1, 0x83, 0xc3, 0xad,
	0x90, 0x2a, 0xa5, 0xdc, 0x1b, 0x9a, 0xe7, 0xc6, 0xc5, 0x19, 0x4c, 0x96, 0x42, 0xc5, 0x32, 0x2d,
	0xaa, 0x56, 0x9e, 0x6b, 0xa2, 0xed, 0x27, 0x3c, 0x86, 0x71, 0x54, 0xea, 0x15, 0x49, 0x6f, 0x64,
	0x82, 0xb5, 0xc7, 0x7e, 0x39, 0x30, 0xb1, 0x03, 0x7c, 0x2d, 0x85, 0xdc, 0xe1, 0x25, 0x1c, 0x92,
	0xa9, 0x50, 0x9e, 0x33, 0x73, 0x4f, 0x26, 0x67, 0x2f, 0x79, 0x47, 0x60, 0x2b, 0x97, 0x7f, 0xb1,
	0x89, 0xd7, 0xb9, 0x96, 0xbb, 0xb0, 0x29, 0xc3, 0x23, 0x38, 0xf8, 0x41, 0x8b, 0x4f, 0x1f, 0xcd,
	0x8c, 0x6e, 0x68, 0x1d, 0xff, 0x02, 0xa6, 0xed, 0x74, 0x7c, 0x0c, 0xee, 0x5a, 0xec, 0x6a, 0x79,
	0x95, 0x59, 0xd5, 0x6d, 0xa3, 0xac, 0x14, 0xb5, 0x36, 0xeb, 0x5c, 0x0c, 0xcf, 0x1d, 0x76, 0x09,
	0x53, 0xfb, 0xd9, 0x50, 0xa8, 0x32, 0xd3, 0x95, 0x16, 0xa5, 0x23, 0x5d, 0xaa, 0xba, 0xbc, 0xf6,
	0x2a, 0x3e, 0x4b, 0xa1, 0xa3, 0x34, 0x53, 0x0d, 0x9f, 0xda, 0x65, 0x73, 0x98, 0xde, 0x69, 0x29,
	0xa2, 0xcd, 0xff, 0x76, 0xa8, 0xf6, 0x91, 0x51, 0xa2, 0x6a, 0xb4, 0xc6, 0x66, 0xaf, 0xe1, 0xe9,
	0x37, 0x92, 0x6b, 0x21, 0x6f, 0xe6, 0xf3, 0x20, 0x20, 0xa9, 0x2d, 0x42, 0x84, 0x51, 0x41, 0x52,
	0x9b, 0xd6, 0x07, 0xa1, 0xb1, 0xcf, 0x7e, 0x0f, 0x1b, 0x0d, 0x76, 0xcf, 0x78, 0x03, 0x0f, 0xfe,
	0xee, 0xfa, 0x98, 0xdb, 0x0b, 0xe1, 0xcd, 0x85, 0xf0, 0xeb, 0xea, 0x42, 0x7c, 0xb6, 0x0f, 0x7d,
	0xf7, 0x4e, 0xd8, 0x00, 0xdf, 0x81, 0x1b, 0x96, 0x39, 0x3e, 0xeb, 0xdd, 0x93, 0xef, 0xef, 0x0b,
	0x59, 0x12, 0x6c, 0x80, 0x1f, 0x60, 0x6c, 0xd9, 0xfc, 0x43, 0x8b, 0x36, 0x4c, 0x36, 0x78, 0xe3,
	0xe0, 0x2d, 0x3c, 0xea, 0xa2, 0xc0, 0x17, 0xdd, 0x8a, 0x3d, 0xa0, 0xfc, 0x1e, 0xdd, 0x6c, 0x80,
	0xe7, 0x30, 0xba, 0xd3, 0x54, 0xf4, 0x92, 0xe9, 0xad, 0xbc, 0xfa, 0x0c, 0xaf, 0x62, 0xda, 0x70,
	0xda, 0xae, 0x78, 0xbc, 0x54, 0x5c, 0x2d, 0xd7, 0x3c, 0x91, 0x45, 0x5c, 0x4f, 0xd1, 0x1e, 0xe9,
	0xea, 0x49, 0x1b, 0x68, 0x50, 0x35, 0x0a, 0x9c, 0xef, 0x9d, 0x5f, 0x77, 0x31, 0x36, 0xfd, 0xdf,
	0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0xb3, 0x1a, 0x70, 0x69, 0xe5, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ActionPluginClient is the client API for ActionPlugin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ActionPluginClient interface {
	Manifest(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionPluginManifest, error)
	Run(ctx context.Context, in *ActionQuery, opts ...grpc.CallOption) (*ActionResult, error)
	Stream(ctx context.Context, in *ActionQuery, opts ...grpc.CallOption) (ActionPlugin_StreamClient, error)
	WorkerHTTPPort(ctx context.Context, in *WorkerHTTPPortQuery, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Stop(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type actionPluginClient struct {
	cc grpc.ClientConnInterface
}

func NewActionPluginClient(cc grpc.ClientConnInterface) ActionPluginClient {
	return &actionPluginClient{cc}
}

func (c *actionPluginClient) Manifest(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ActionPluginManifest, error) {
	out := new(ActionPluginManifest)
	err := c.cc.Invoke(ctx, "/actionplugin.ActionPlugin/Manifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionPluginClient) Run(ctx context.Context, in *ActionQuery, opts ...grpc.CallOption) (*ActionResult, error) {
	out := new(ActionResult)
	err := c.cc.Invoke(ctx, "/actionplugin.ActionPlugin/Run", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionPluginClient) Stream(ctx context.Context, in *ActionQuery, opts ...grpc.CallOption) (ActionPlugin_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ActionPlugin_serviceDesc.Streams[0], "/actionplugin.ActionPlugin/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &actionPluginStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ActionPlugin_StreamClient interface {
	Recv() (*StreamResult, error)
	grpc.ClientStream
}

type actionPluginStreamClient struct {
	grpc.ClientStream
}

func (x *actionPluginStreamClient) Recv() (*StreamResult, error) {
	m := new(StreamResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *actionPluginClient) WorkerHTTPPort(ctx context.Context, in *WorkerHTTPPortQuery, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/actionplugin.ActionPlugin/WorkerHTTPPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *actionPluginClient) Stop(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/actionplugin.ActionPlugin/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActionPluginServer is the server API for ActionPlugin service.
type ActionPluginServer interface {
	Manifest(context.Context, *emptypb.Empty) (*ActionPluginManifest, error)
	Run(context.Context, *ActionQuery) (*ActionResult, error)
	Stream(*ActionQuery, ActionPlugin_StreamServer) error
	WorkerHTTPPort(context.Context, *WorkerHTTPPortQuery) (*emptypb.Empty, error)
	Stop(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedActionPluginServer can be embedded to have forward compatible implementations.
type UnimplementedActionPluginServer struct {
}

func (*UnimplementedActionPluginServer) Manifest(ctx context.Context, req *emptypb.Empty) (*ActionPluginManifest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Manifest not implemented")
}
func (*UnimplementedActionPluginServer) Run(ctx context.Context, req *ActionQuery) (*ActionResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (*UnimplementedActionPluginServer) Stream(req *ActionQuery, srv ActionPlugin_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}
func (*UnimplementedActionPluginServer) WorkerHTTPPort(ctx context.Context, req *WorkerHTTPPortQuery) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerHTTPPort not implemented")
}
func (*UnimplementedActionPluginServer) Stop(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}

func RegisterActionPluginServer(s *grpc.Server, srv ActionPluginServer) {
	s.RegisterService(&_ActionPlugin_serviceDesc, srv)
}

func _ActionPlugin_Manifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionPluginServer).Manifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/actionplugin.ActionPlugin/Manifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionPluginServer).Manifest(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionPlugin_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionPluginServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/actionplugin.ActionPlugin/Run",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionPluginServer).Run(ctx, req.(*ActionQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionPlugin_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ActionQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ActionPluginServer).Stream(m, &actionPluginStreamServer{stream})
}

type ActionPlugin_StreamServer interface {
	Send(*StreamResult) error
	grpc.ServerStream
}

type actionPluginStreamServer struct {
	grpc.ServerStream
}

func (x *actionPluginStreamServer) Send(m *StreamResult) error {
	return x.ServerStream.SendMsg(m)
}

func _ActionPlugin_WorkerHTTPPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerHTTPPortQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionPluginServer).WorkerHTTPPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/actionplugin.ActionPlugin/WorkerHTTPPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionPluginServer).WorkerHTTPPort(ctx, req.(*WorkerHTTPPortQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActionPlugin_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActionPluginServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/actionplugin.ActionPlugin/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActionPluginServer).Stop(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ActionPlugin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "actionplugin.ActionPlugin",
	HandlerType: (*ActionPluginServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Manifest",
			Handler:    _ActionPlugin_Manifest_Handler,
		},
		{
			MethodName: "Run",
			Handler:    _ActionPlugin_Run_Handler,
		},
		{
			MethodName: "WorkerHTTPPort",
			Handler:    _ActionPlugin_WorkerHTTPPort_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ActionPlugin_Stop_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _ActionPlugin_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "actionplugin.proto",
}
