package api

import (
	"context"
	"net/http"
	"regexp"

	"github.com/gorilla/mux"
	"github.com/ovh/cds/engine/api/authentication"
	"github.com/ovh/cds/engine/api/event"
	"github.com/ovh/cds/engine/api/event_v2"
	"github.com/ovh/cds/engine/api/group"
	"github.com/ovh/cds/engine/api/integration"
	"github.com/ovh/cds/engine/api/keys"
	"github.com/ovh/cds/engine/api/permission"
	"github.com/ovh/cds/engine/api/project"
	"github.com/ovh/cds/engine/api/rbac"
	"github.com/ovh/cds/engine/service"
	"github.com/ovh/cds/sdk"
	"github.com/ovh/cds/sdk/slug"
)

func (api *API) postProjectV2Handler() service.Handler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
		consumer := getUserConsumer(ctx)
		if consumer == nil {
			return sdk.WithStack(sdk.ErrForbidden)
		}

		if api.Config.Project.CreationDisabled && !isAdmin(ctx) {
			return sdk.NewErrorFrom(sdk.ErrForbidden, "project creation is disabled")
		}

		var prj sdk.Project
		if err := service.UnmarshalBody(r, &prj); err != nil {
			return err
		}

		// Check key pattern
		if rgxp := regexp.MustCompile(sdk.ProjectKeyPattern); !rgxp.MatchString(prj.Key) {
			return sdk.WrapError(sdk.ErrInvalidProjectKey, "project key %s do not respect pattern %s", prj.Key, sdk.ProjectKeyPattern)
		}

		// Check project name
		if prj.Name == "" {
			return sdk.WrapError(sdk.ErrInvalidProjectName, "project name must no be empty")
		}

		if prj.WorkflowRetention <= 0 {
			prj.WorkflowRetention = api.Config.WorkflowV2.WorkflowRunRetention
		}

		// Create a project within a transaction
		tx, err := api.mustDB().Begin()
		if err != nil {
			return sdk.WrapError(err, "cannot start transaction")
		}
		defer tx.Rollback() // nolint

		// Check that project does not already exists
		exist, errExist := project.Exist(tx, prj.Key)
		if errExist != nil {
			return sdk.WrapError(errExist, "cannot check if project %s exist", prj.Key)
		}
		if exist {
			return sdk.NewErrorFrom(sdk.ErrAlreadyExist, "project %s already exists", prj.Key)
		}

		if err := project.Insert(tx, &prj); err != nil {
			return err
		}

		// Check that given project groups are valid
		var groupIDs []int64
		for _, gp := range prj.ProjectGroups {
			var grp *sdk.Group
			var err error
			if gp.Group.ID != 0 {
				grp, err = group.LoadByID(ctx, tx, gp.Group.ID, group.LoadOptions.WithMembers)
			} else {
				grp, err = group.LoadByName(ctx, tx, gp.Group.Name, group.LoadOptions.WithMembers)
			}
			if err != nil {
				return err
			}

			// the default group could not be selected
			if group.IsDefaultGroupID(grp.ID) {
				return sdk.NewErrorFrom(sdk.ErrWrongRequest, "cannot use default group to create project")
			}

			// consumer should be group member to add it on a project
			if !isGroupMember(ctx, grp) {
				if isAdmin(ctx) {
					trackSudo(ctx, w)
				} else {
					return sdk.WithStack(sdk.ErrInvalidGroupMember)
				}
			}

			groupIDs = append(groupIDs, grp.ID)
		}

		// If no groups were given, try to create a new one with project name
		if len(groupIDs) == 0 {
			groupSlug := slug.Convert(prj.Name)
			existingGroop, err := group.LoadByName(ctx, tx, groupSlug)
			if err != nil && !sdk.ErrorIs(err, sdk.ErrNotFound) {
				return err
			}
			if existingGroop != nil {
				return sdk.NewErrorFrom(sdk.ErrWrongRequest, "cannot create a new group %s for given project name", groupSlug)
			}

			newGroup := sdk.Group{Name: groupSlug}
			if err := group.Create(ctx, tx, &newGroup, consumer.AuthConsumerUser.AuthentifiedUser); err != nil {
				return err
			}

			groupIDs = []int64{newGroup.ID}
		}

		// Insert all links between project and group
		for _, groupID := range groupIDs {
			if err := group.InsertLinkGroupProject(ctx, tx, &group.LinkGroupProject{
				GroupID:   groupID,
				ProjectID: prj.ID,
				Role:      sdk.PermissionReadWriteExecute,
			}); err != nil {
				return sdk.WrapError(err, "cannot add group %d in project %s", groupID, prj.Name)
			}
		}

		for _, v := range prj.Variables {
			if errVar := project.InsertVariable(tx, prj.ID, &v, consumer); errVar != nil {
				return sdk.WrapError(errVar, "addProjectHandler> Cannot add variable %s in project %s", v.Name, prj.Name)
			}
		}

		prj.Keys = []sdk.ProjectKey{
			{
				Type: sdk.KeyTypeSSH,
				Name: sdk.GenerateProjectDefaultKeyName(prj.Key, sdk.KeyTypeSSH),
			},
			{
				Type: sdk.KeyTypePGP,
				Name: sdk.GenerateProjectDefaultKeyName(prj.Key, sdk.KeyTypePGP),
			},
		}
		for i := range prj.Keys {
			k := &prj.Keys[i]
			k.ProjectID = prj.ID

			var newKey sdk.Key
			var err error
			switch k.Type {
			case sdk.KeyTypePGP:
				var email string
				email, err = api.gpgKeyEmailAddress(ctx, prj.Key, k.Name)
				if err != nil {
					return err
				}
				newKey, err = keys.GeneratePGPKeyPair(k.Name, "Project Key generated by CDS", email)
			case sdk.KeyTypeSSH:
				newKey, err = keys.GenerateSSHKey(k.Name)
			}
			if err != nil {
				return err
			}
			k.Private = newKey.Private
			k.Public = newKey.Public
			k.KeyID = newKey.KeyID

			if err := project.InsertKey(tx, k); err != nil {
				return sdk.WrapError(err, "cannot add key %s in project %s", k.Name, prj.Name)
			}
		}

		integrationModels, err := integration.LoadModels(tx)
		if err != nil {
			return sdk.WrapError(err, "cannot load integration models")
		}

		var created, updated []sdk.ProjectIntegration
		for i := range integrationModels {
			pf := &integrationModels[i]
			created, updated, err = propagatePublicIntegrationModelOnProject(ctx, tx, api.Cache, *pf, prj, consumer)
			if err != nil {
				return sdk.WithStack(err)
			}
		}

		if err := tx.Commit(); err != nil {
			return sdk.WithStack(err)
		}

		event.PublishAddProject(ctx, &prj, consumer)
		for _, pp := range created {
			event_v2.PublishProjectIntegrationEvent(ctx, api.Cache, sdk.EventIntegrationCreated, permProjectKey, pp, *consumer.AuthConsumerUser.AuthentifiedUser)
		}
		for _, pp := range updated {
			event_v2.PublishProjectIntegrationEvent(ctx, api.Cache, sdk.EventIntegrationUpdated, permProjectKey, pp, *consumer.AuthConsumerUser.AuthentifiedUser)
		}
		event_v2.PublishProjectEvent(ctx, api.Cache, sdk.EventProjectCreated, prj, *consumer.AuthConsumerUser.AuthentifiedUser)

		proj, err := project.Load(ctx, api.mustDB(), prj.Key,
			project.LoadOptions.WithLabels,
			project.LoadOptions.WithWorkflowNames,
			project.LoadOptions.WithFavorites(consumer.AuthConsumerUser.AuthentifiedUser.ID),
			project.LoadOptions.WithKeys,
			project.LoadOptions.WithIntegrations,
			project.LoadOptions.WithVariables,
		)
		if err != nil {
			return sdk.WrapError(err, "cannot load project %s", prj.Key)
		}
		proj.Permissions.Readable = true
		proj.Permissions.Writable = true

		return service.WriteJSON(w, *proj, http.StatusCreated)
	}
}

func (api *API) getProjectsV2Handler() ([]service.RbacChecker, service.Handler) {
	return service.RBAC(),
		func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {

			u := getUserConsumer(ctx)
			if u == nil {
				return sdk.WithStack(sdk.ErrForbidden)
			}

			// For admin
			if isAdmin(ctx) {
				projects, err := project.LoadAll(ctx, api.mustDB(), api.Cache)
				if err != nil {
					return err
				}
				return service.WriteJSON(w, projects, http.StatusOK)
			}

			// Normal user
			keys, err := rbac.LoadAllProjectKeysAllowed(ctx, api.mustDB(), sdk.ProjectRoleRead, u.AuthConsumerUser.AuthentifiedUserID)
			if err != nil {
				return err
			}

			projects, err := project.LoadAllByKeys(ctx, api.mustDB(), keys)
			if err != nil {
				return err
			}
			return service.WriteJSON(w, projects, http.StatusOK)
		}
}

func (api *API) deleteProjectV2Handler() ([]service.RbacChecker, service.Handler) {
	return service.RBAC(api.projectManage),
		func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
			// Get project name in URL
			vars := mux.Vars(r)
			key := vars["projectKey"]

			u := getUserConsumer(ctx)
			if u == nil {
				return sdk.WithStack(sdk.ErrForbidden)
			}

			p, err := project.Load(ctx, api.mustDB(), key, project.LoadOptions.WithPipelines, project.LoadOptions.WithApplications)
			if err != nil {
				if !sdk.ErrorIs(err, sdk.ErrNoProject) {
					return sdk.WrapError(err, "deleteProject> load project '%s' from db", key)
				}
				return sdk.WrapError(err, "cannot load project %s", key)
			}

			// TODO Delete
			if len(p.Pipelines) > 0 {
				return sdk.WrapError(sdk.ErrProjectHasPipeline, "project '%s' still used by %d pipelines", key, len(p.Pipelines))
			}

			if len(p.Applications) > 0 {
				return sdk.WrapError(sdk.ErrProjectHasApplication, "project '%s' still used by %d applications", key, len(p.Applications))
			}
			//

			tx, err := api.mustDB().Begin()
			if err != nil {
				return sdk.WithStack(err)
			}
			defer tx.Rollback() // nolint

			if err := project.Delete(tx, p.Key); err != nil {
				return err
			}
			if err := tx.Commit(); err != nil {
				return sdk.WithStack(err)
			}

			event_v2.PublishProjectEvent(ctx, api.Cache, sdk.EventProjectDeleted, *p, *u.AuthConsumerUser.AuthentifiedUser)
			return nil
		}
}

func (api *API) updateProjectV2Handler() ([]service.RbacChecker, service.Handler) {
	return service.RBAC(api.projectRead),
		func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
			// Get project name in URL
			vars := mux.Vars(r)
			key := vars["projectKey"]

			u := getUserConsumer(ctx)
			if u == nil {
				return sdk.WithStack(sdk.ErrForbidden)
			}

			proj := &sdk.Project{}
			if err := service.UnmarshalBody(r, proj); err != nil {
				return sdk.WithStack(err)
			}

			if proj.Name == "" {
				return sdk.WrapError(sdk.ErrInvalidProjectName, "project name must no be empty")
			}

			// Check Request
			if key != proj.Key {
				return sdk.WrapError(sdk.ErrWrongRequest, "bad Project key %s/%s ", key, proj.Key)
			}

			if proj.WorkflowRetention <= 0 {
				proj.WorkflowRetention = api.Config.WorkflowV2.WorkflowRunRetention
			}

			// Check is project exist
			p, err := project.Load(ctx, api.mustDB(), key, project.LoadOptions.WithIcon)
			if err != nil {
				return err
			}
			// Update in DB is made given the primary key
			proj.ID = p.ID
			proj.VCSServers = p.VCSServers
			if proj.Icon == "" {
				p.Icon = proj.Icon
			}
			if err := project.Update(api.mustDB(), proj); err != nil {
				return sdk.WrapError(err, "cannot update project %s", key)
			}
			event_v2.PublishProjectEvent(ctx, api.Cache, sdk.EventProjectUpdated, *proj, *u.AuthConsumerUser.AuthentifiedUser)

			proj.Permissions.Readable = true
			proj.Permissions.Writable = true

			return service.WriteJSON(w, proj, http.StatusOK)
		}
}

func (api *API) getProjectV2Handler() ([]service.RbacChecker, service.Handler) {
	return service.RBAC(api.projectRead),
		func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
			// Get project name in URL
			vars := mux.Vars(r)
			key := vars["projectKey"]

			p, errProj := project.Load(ctx, api.mustDB(), key)
			if errProj != nil {
				return sdk.WrapError(errProj, "getProjectHandler (%s)", key)
			}

			// TODO REMOVE
			if isAdmin(ctx) {
				p.Permissions = sdk.Permissions{Readable: true, Writable: true, Executable: true}
			} else {
				permissions, err := permission.LoadProjectMaxLevelPermission(ctx, api.mustDB(), []string{p.Key}, getUserConsumer(ctx).GetGroupIDs())
				if err != nil {
					return err
				}
				p.Permissions = permissions.Permissions(p.Key)
				if isMaintainer(ctx) {
					p.Permissions.Readable = true
				}
			}

			return service.WriteJSON(w, p, http.StatusOK)
		}
}

func (api *API) getProjectV2AccessHandler() ([]service.RbacChecker, service.Handler) {
	return service.RBAC(api.isCDNService),
		func(ctx context.Context, w http.ResponseWriter, req *http.Request) error {
			vars := mux.Vars(req)

			projectKey := vars["projectKey"]
			itemType := vars["type"]

			if sdk.CDNItemType(itemType) == sdk.CDNTypeItemWorkerCache {
				return sdk.WrapError(sdk.ErrForbidden, "cdn is not enabled for this type %s", itemType)
			}

			sessionID := req.Header.Get(sdk.CDSSessionID)
			if sessionID == "" {
				return sdk.WrapError(sdk.ErrForbidden, "missing session id header")
			}

			session, err := authentication.LoadSessionByID(ctx, api.mustDBWithCtx(ctx), sessionID)
			if err != nil {
				return err
			}
			consumer, err := authentication.LoadUserConsumerByID(ctx, api.mustDB(), session.ConsumerID,
				authentication.LoadUserConsumerOptions.WithAuthentifiedUser)
			if err != nil {
				return sdk.NewErrorWithStack(err, sdk.ErrUnauthorized)
			}

			if consumer.Disabled {
				return sdk.WrapError(sdk.ErrUnauthorized, "consumer (%s) is disabled", consumer.ID)
			}

			maintainerOrAdmin := consumer.Maintainer() || consumer.Admin()
			canRead, err := rbac.HasRoleOnProjectAndUserID(ctx, api.mustDB(), sdk.ProjectRoleRead, consumer.AuthConsumerUser.AuthentifiedUserID, projectKey)
			if err != nil {
				return err
			}

			if maintainerOrAdmin || canRead {
				return service.WriteJSON(w, nil, http.StatusOK)
			}
			return service.WriteJSON(w, nil, http.StatusForbidden)
		}
}
